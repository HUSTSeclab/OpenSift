## 执行流程

每次任务队列为空时，从数据库取若干个（少量）新任务，

### 为什么取少量任务？

因为数据库是不断变化的，为了能让 worker 可以处理到优先级高的任务，每次从数据库取任务时，都只取一小部分，然后交给 worker 处理。

执行完这一小部分任务后，优先级更高的任务可能已经被加入到数据库中，比如重新执行了 union 等操作，这时再次从数据库取任务，就能取到这些优先级更高的任务，相当于抢占式调度。

## 自定义量
- 首次重试间隔
- 最大重试间隔
- 同步间隔时间函数，interval(commit_freq)

## 优先级排列
1. 手动指定的任务
    - 组内排序：(a) 手动指定 nice 值 (b) 任务提交时间
2. 从来没有执行过的任务，比如新加入的仓库链接
    - 组内排序：字典序
3. 到达等待时间的同步失败的任务
    - 组内排序：上次失败时间
    - PS: 同步失败的任务，采用指数退避算法，每次失败后，等待时间翻倍，直到超过最大等待时间，然后等待最大等待时间，然后再次尝试。
    - 重试间隔可以动态设定，如果任务失败次数过多，可以适当增加重试间隔，避免 第 4 优先级的任务饥饿。 
4. 距离上次同步时间 > 间隔时间的任务，
    - 其中，间隔时间 = interval(commit_freq)，是一个函数，与 commit 频率有关
    - 组内排序：距离上次同步时间与间隔时间的差值

如果以上 4 种任务都没有，就进入 idle 状态，每隔一小段时间检查一次任务队列。